/* eslint-disable no-restricted-globals */
import { clientsClaim } from 'workbox-core';
import { precacheAndRoute, cleanupOutdatedCaches } from 'workbox-precaching';
import { registerRoute } from 'workbox-routing';
import { NetworkFirst, CacheFirst } from 'workbox-strategies';
import { ExpirationPlugin } from 'workbox-expiration';

// Take control of all pages immediately
clientsClaim();

// Clean up old caches
cleanupOutdatedCaches();

// Precache all assets generated by Vite
precacheAndRoute(self.__WB_MANIFEST);

// Skip waiting and activate immediately
self.skipWaiting();

// ==========================================
// BADGE MANAGEMENT (IndexedDB)
// ==========================================

const DB_NAME = 'NotificationDB';
const STORE_NAME = 'unreadCount';
const UNREAD_KEY = 'count';

function openDB() {
  return new Promise((resolve, reject) => {
    const request = indexedDB.open(DB_NAME, 1);

    request.onerror = () => reject(request.error);
    request.onsuccess = () => resolve(request.result);

    request.onupgradeneeded = (event) => {
      const db = event.target.result;
      if (!db.objectStoreNames.contains(STORE_NAME)) {
        db.createObjectStore(STORE_NAME);
      }
    };
  });
}

async function getUnreadCount() {
  try {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readonly');
      const store = tx.objectStore(STORE_NAME);
      const req = store.get(UNREAD_KEY);

      req.onsuccess = () => resolve(req.result || 0);
      req.onerror = () => reject(req.error);
    });
  } catch (err) {
    console.error('âŒ Failed to get unread count', err);
    return 0;
  }
}

async function setUnreadCount(count) {
  try {
    const db = await openDB();
    return new Promise((resolve, reject) => {
      const tx = db.transaction(STORE_NAME, 'readwrite');
      const store = tx.objectStore(STORE_NAME);
      const req = store.put(count, UNREAD_KEY);

      req.onsuccess = () => resolve();
      req.onerror = () => reject(req.error);
    });
  } catch (err) {
    console.error('âŒ Failed to set unread count', err);
  }
}

async function incrementUnreadCount() {
  const current = await getUnreadCount();
  const next = current + 1;
  await setUnreadCount(next);
  return next;
}

async function decrementUnreadCount() {
  const current = await getUnreadCount();
  const next = Math.max(0, current - 1);
  await setUnreadCount(next);
  return next;
}

async function updateBadge(count) {
  try {
    if ('setAppBadge' in navigator) {
      if (count > 0) {
        await navigator.setAppBadge(count);
      } else {
        await navigator.clearAppBadge();
      }
    }
  } catch (err) {
    console.error('âŒ Badge update failed', err);
  }
}

// ==========================================
// CACHING STRATEGIES
// ==========================================

registerRoute(
  ({ request }) => request.destination === 'image',
  new CacheFirst({
    cacheName: 'images-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 30 * 24 * 60 * 60,
      }),
    ],
  })
);

registerRoute(
  ({ request }) => request.destination === 'font',
  new CacheFirst({
    cacheName: 'fonts-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 20,
        maxAgeSeconds: 365 * 24 * 60 * 60,
      }),
    ],
  })
);

registerRoute(
  ({ url }) => url.pathname.startsWith('/api/'),
  new NetworkFirst({
    cacheName: 'api-cache',
    plugins: [
      new ExpirationPlugin({
        maxEntries: 50,
        maxAgeSeconds: 5 * 60,
      }),
    ],
  })
);

// ==========================================
// PUSH NOTIFICATIONS
// ==========================================

self.addEventListener('push', (event) => {
  let data = {};

  if (event.data) {
    try {
      data = event.data.json();
    } catch {
      data = { title: 'Notification', body: event.data.text() };
    }
  }

  const title = data.title || 'Abytech Hub';

  const options = {
    body: data.body || data.message || 'New message',
    icon: data.icon || '/pwa-192x192.png',
    badge: data.badge || '/pwa-72x72.png',
    data: data.data || { url: data.url, notificationId: data.notificationId },
    tag: data.tag || data.notificationId || 'abytech-notification',
    requireInteraction: !!data.requireInteraction,
    vibrate: data.vibrate || [300, 200, 300],
    renotify: true,
    timestamp: Date.now(),
    actions: Array.isArray(data.actions) ? data.actions : undefined,
  };

  event.waitUntil(
    (async () => {
      await self.registration.showNotification(title, options);
      const count = await incrementUnreadCount();
      await updateBadge(count);
    })()
  );
});

self.addEventListener('notificationclick', (event) => {
  event.notification.close();

  const data = event.notification.data || {};
  const url = data.notificationId
    ? `${data.url}?notificationId=${data.notificationId}`
    : data.url || '/';

  event.waitUntil(
    (async () => {
      const count = await decrementUnreadCount();
      await updateBadge(count);

      const clientsList = await self.clients.matchAll({
        type: 'window',
        includeUncontrolled: true,
      });

      for (const client of clientsList) {
        if (client.url.includes(url) && client.focus) {
          return client.focus();
        }
      }

      if (self.clients.openWindow) {
        return self.clients.openWindow(url);
      }
    })()
  );
});

self.addEventListener('notificationclose', (event) => {
  event.waitUntil(
    (async () => {
      const count = await decrementUnreadCount();
      await updateBadge(count);
    })()
  );
});

// ==========================================
// LIFECYCLE
// ==========================================

self.addEventListener('install', () => self.skipWaiting());

self.addEventListener('activate', (event) => {
  event.waitUntil(
    (async () => {
      await self.clients.claim();
      const count = await getUnreadCount();
      await updateBadge(count);
    })()
  );
});

self.addEventListener('message', (event) => {
  if (event.data?.type === 'SKIP_WAITING') {
    self.skipWaiting();
  }

  if (event.data?.type === 'UPDATE_BADGE') {
    event.waitUntil(
      setUnreadCount(event.data.count || 0).then(() =>
        updateBadge(event.data.count || 0)
      )
    );
  }

  if (event.data?.type === 'NOTIFICATION_READ') {
    event.waitUntil(
      decrementUnreadCount().then(updateBadge)
    );
  }
});

console.log('ðŸš€ Service Worker (JS) ready');
